
# Trapezoidal_1 -----------------------------------------------------------
# https://en.wikipedia.org/wiki/Trapezoidal_rule

# the code generated by chatGPT on Feb 6, 2023
integrate_trapezoidal_1 <- function(f, a, b, n) {
  h <- (b - a) / n
  result <- (f(a) + f(b)) / 2
  for (i in 1:(n - 1)) {
    result <- result + f(a + i * h)
  }
  result <- result * h
  return(result)
}

myfn<- function(x){
  p<-1/sqrt(2*pi)*exp(-x^2/2)
  return(p)
}

1/2-integrate_trapezoidal_1(myfn,0,1.96,100) # P(X>1.96)

integrate_trapezoidal_1(function(x) x^2, 0, 1,10)


# Trapezoidal_2 -----------------------------------------------------------
# I can do it myself using vector programming instead of using for loop
integrate_trapezoidal_2<- function(myfn,a,b,n) {
  h<-(b-a)/n
  x.vec <- seq(a,b,by = h)
  f.vec <- sapply(x.vec, myfn) 
  A<- h*(f.vec[1]/2+sum(f.vec[2:n])+f.vec[n+1]/2)
  return(A)
}

myfn<- function(x){
  p<-1/sqrt(2*pi)*exp(-x^2/2)
  return(p)
}

1/2-integrate_trapezoidal_2(myfn,0,1.96,100) # P(X>1.96)


# Simpson's rule ----------------------------------------------------------

integrate_simpson<- function(myfn,a,b,n) {
  h<-(b-a)/n
  x.vec <- seq(a,b,by = h)
  f.vec <- sapply(x.vec, myfn) 
  sum<- f.vec[1]+f.vec[n+1]
  for (i in 2:n){
    if (i%%2 == 0)
      sum = sum + 4*f.vec[i] #f.vec[2] corresponding to f(x1)
    else 
      sum = sum + 2*f.vec[i] #f.vec[3] corresponding to f(x2)
  }
  sum = sum*h/3
  print(sum)
}

myfn<- function(x){
  p<-1/sqrt(2*pi)*exp(-x^2/2)
  return(p)
}

1/2-integrate_simpson(myfn,0,1.96,100) # P(X>1.96)
integrate_simpson(function(x) x^2, 0, 1, 10)




# Simpson rule code by chatGPT --------------------------------------------

simpson_rule <- function(f, a, b, n) {
  h <- (b - a) / n
  x <- seq(a, b, length.out = n + 1)
  y <- f(x)
  result <- h / 3 * (y[1] + 4 * sum(y[seq(2, n, 2)]) + 2 * sum(y[seq(3, n-1, 2)]) + y[n + 1])
  return(result)
}

simpson_rule(function(x) x^2, 0, 1, 10)




factorial <- function(n) {
  if (n <= 1) {
    return(1)
  } else {
    return(n * factorial(n - 1))
  }
}

gcd <- function(a, b) {
  if (b == 0) {
    return(a)
  } else {
    return(gcd(b, a %% b))
  }
}


integrand <- function(x) 1/((x+1)*sqrt(x))
integrate(integrand, lower = 0, upper = Inf)
